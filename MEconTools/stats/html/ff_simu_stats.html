
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>FF_SIMU_STATS Gateway Probability Mass Statistics</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-06-21"><meta name="DC.source" content="ff_simu_stats.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>FF_SIMU_STATS Gateway Probability Mass Statistics</h1><!--introduction--><pre>  Given probability mass function f(s), and information y(s), x(s), z(s)
  at each element of the state-space, compute statistics for each
  variable, y, x, z, which are all discrete random variables. And
  compute their correlation and covariance. The function can take any
  number of outcome matrixes, y(s), ..., z(s), stored as values of
  associated with keys that name these variables in a container map.</pre><pre>  * MT_F_OF_S matrix or array probability mass at each s point
  * MP_MT_XYZ_OF_S container map of matrix with MT_X_OF_S
  * MP_SUPPORT_EXT container map with various control strings with
  defaults</pre><pre>  MP_MT_XYZ_OF_S keys and Example Values:</pre><pre>  mp_mt_xyz_of_s = containers.Map('KeyType', 'char', 'ValueType', 'any');
  mp_mt_xyz_of_s('ar_st_y_name') = {'cl_mt_pol_a', 'cl_mt_pol_b', 'cl_mt_pol_c'};
  mp_mt_xyz_of_s('cl_mt_pol_a') = {mt_pol_a, zeros(1)};
  mp_mt_xyz_of_s('cl_mt_pol_b') = {mt_pol_b, zeros(1)};
  mp_mt_xyz_of_s('cl_mt_pol_c') = {mt_pol_b, zeros(1)};</pre><pre>  MP_MT_XYZ_OF_S = FF_SIMU_STATS() default simulation stats outputs.</pre><pre>  MP_MT_XYZ_OF_S = FF_DISC_RAND_VAR_MASS2COVCOR(MT_F_OF_S,
  MP_CL_MT_XYZ_OF_S) calculates various statistics given the provided
  distribution matrix and various outcome/states matrixes.</pre><pre>  MP_MT_XYZ_OF_S = FF_DISC_RAND_VAR_MASS2COVCOR(MT_F_OF_S,
  MP_CL_MT_XYZ_OF_S, MP_SUPPORT_EXT) provides some additional control
  strings if to print verbose in each stat function.</pre><pre>  See also FX_SIMU_STATS</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">FF_SIMU_STATS post simulation statistics generation</a></li><li><a href="#3">Default</a></li><li><a href="#4">Set and Update Support Map</a></li><li><a href="#5">Parse mp_mt_xyz_of_s</a></li><li><a href="#6"><b>f(y), f(c), f(a)</b>: Generate Key Distributional Statistics for Each outcome</a></li><li><a href="#8"><b>f(y), f(c), f(a)</b>: Find p(outcome(states)), proability mass function for each outcome</a></li><li><a href="#9"><b>f(y), f(c), f(a)</b>: Compute Statistics for outcomes</a></li><li><a href="#10"><b>f(y), f(c), f(a)</b>: Store Statistics Specific to Each Outcome</a></li><li><a href="#12">Covariance and Correlation</a></li><li><a href="#13"><b>f(y), f(c), f(a)</b>: Store Statistics Shared Table All Outcomes</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> mp_cl_mt_xyz_of_s = ff_simu_stats(varargin)
</pre><h2 id="2">FF_SIMU_STATS post simulation statistics generation</h2><p>Having derived f(a,z) the probability mass function of the joint discrete random variables, we now obtain distributional statistics. Note that we know f(a,z), and we also know relevant policy functions a'(a,z), c(a,z), or other policy functions. We can simulate any choices that are a function of the random variables (a,z), using f(a,z)</p><p>parameter structure provides a list of</p><div><ol><li>from result_map('ar_st_y_name'), get list of outcome matrix on state space</li><li>simulate each outcome using f(a,z) for probability draws</li><li>compute key statistics: (1) mean (expectation=sum) (2) sd (3) min and max (4) iqr (5) fraction = 0 (6) percentiles including: 99.9, 99, 95, every 5 in between 5, 1, 0.01.</li></ol></div><p>Uses fake binomial data when file is invoke with defaults.</p><div><ul><li>the first element of each of these cell array is y(a,z), the outcome/choice at the state space points</li><li>the second element of the cell is another container, which contains statistics computed for f(y) based on y(a,z) and f(a,z), f(y) is the probability mass function for outcome y given the stationary distribution f(a,z). The second element container also includes f(y) itself as well as f(y,z).</li><li>additionally, result_map also stores some of the statistics for different variables jointly together. (a) <b>tb_outcomes_meansdperc</b>: where each row is a different outcome of the model, and each table column stores a different statistics of interest. (b) <b>tb_outcomes_fracheld</b>: which measures the fraction of asset held by different people.</li></ul></div><h2 id="3">Default</h2><p>use binomial as test case, z maps to binomial win prob, remember binom approximates normal.</p><pre class="codeinput"><span class="keyword">if</span> (~isempty(varargin))

    <span class="keyword">if</span> (length(varargin)==2)
        [mt_f_of_s, mp_cl_mt_xyz_of_s] = varargin{:};
    <span class="keyword">elseif</span> (length(varargin)==3)
        [mt_f_of_s, mp_cl_mt_xyz_of_s, mp_support_ext] = varargin{:};
    <span class="keyword">end</span>

    <span class="comment">% if invoked from outside overrid fully</span>
<span class="keyword">else</span>

    it_states = 6;
    it_shocks = 5;
    fl_binom_n = it_states-1;
    ar_binom_p = (1:(it_shocks))./(it_shocks+2);
    ar_binom_x = (0:1:(it_states-1)) -3;

    <span class="comment">% f(z)</span>
    ar_binom_p_prob = binopdf(0:(it_shocks-1), it_shocks-1, 0.5);
    <span class="comment">% f(a,z), mass for a, z</span>
    mt_f_of_s = zeros([it_states, it_shocks]);
    <span class="keyword">for</span> it_z=1:it_shocks
        <span class="comment">% f(a|z)</span>
        f_a_condi_z = binopdf(ar_binom_x - min(ar_binom_x), fl_binom_n, ar_binom_p(it_z));
        <span class="comment">% f(z)</span>
        f_z = ar_binom_p_prob(it_z);
        <span class="comment">% f(a,z)=f(a|z)*f(z)</span>
        mt_f_of_s(:, it_z) = f_a_condi_z*f_z;
    <span class="keyword">end</span>

    <span class="comment">% y(a,z), some non-smooth structure</span>
    rng(123);
    mt_pol_a = ar_binom_x' - 0.01*ar_binom_x'.^2  + ar_binom_p - 0.5*ar_binom_p.^2 + rand([it_states, it_shocks]);
    mt_pol_a = round(mt_pol_a*3);

    rng(456);
    mt_pol_c = 10 -(mt_pol_a) + 15*(rand([it_states, it_shocks])-0.5);

    <span class="comment">% Generate result_map</span>
    <span class="comment">% two column, the second zero(1) component left for disc rand var of a,</span>
    <span class="comment">% c</span>
    mp_cl_mt_xyz_of_s = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>, <span class="string">'ValueType'</span>,<span class="string">'any'</span>);
    mp_cl_mt_xyz_of_s(<span class="string">'cl_mt_pol_a'</span>) = {mt_pol_a, zeros(1)};
    mp_cl_mt_xyz_of_s(<span class="string">'cl_mt_pol_c'</span>) = {mt_pol_c, zeros(1)};
    mp_cl_mt_xyz_of_s(<span class="string">'ar_st_y_name'</span>) = [<span class="string">"cl_mt_pol_a"</span>, <span class="string">"cl_mt_pol_c"</span>];

<span class="keyword">end</span>
</pre><h2 id="4">Set and Update Support Map</h2><pre class="codeinput">mp_support = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>, <span class="string">'ValueType'</span>,<span class="string">'any'</span>);
mp_support(<span class="string">'bl_display_detail'</span>) = false;
mp_support(<span class="string">'bl_display_final'</span>) = true;

<span class="comment">% for ff_disc_rand_var_mass2outcomes.m</span>
mp_support(<span class="string">'bl_display_drvm2outcomes'</span>) = false;

<span class="comment">% for ff_disc_rand_var_stats.m</span>
mp_support(<span class="string">'ar_fl_percentiles'</span>) = [1 10 25 50 75 90 99];
mp_support(<span class="string">'bl_display_drvstats'</span>) = false;

<span class="comment">% for ff_disc_rand_var_stats.m</span>
mp_support(<span class="string">'bl_display_drvm2covcor'</span>) = false;

<span class="comment">% override default support_map values</span>
<span class="keyword">if</span> (length(varargin)==3)
    mp_support = [mp_support; mp_support_ext];
<span class="keyword">end</span>

<span class="comment">% Parse Support_map</span>
params_group = values(mp_support, {<span class="string">'bl_display_detail'</span>, <span class="string">'bl_display_final'</span>});
[bl_display_detail, bl_display_final] = params_group{:};
params_group = values(mp_support, {<span class="string">'bl_display_drvm2outcomes'</span>});
[bl_display_drvm2outcomes] = params_group{:};
params_group = values(mp_support, {<span class="string">'ar_fl_percentiles'</span>, <span class="string">'bl_display_drvstats'</span>});
[ar_fl_percentiles, bl_display_drvstats] = params_group{:};
params_group = values(mp_support, {<span class="string">'bl_display_drvm2covcor'</span>});
[bl_display_drvm2covcor] = params_group{:};
</pre><h2 id="5">Parse mp_mt_xyz_of_s</h2><p>result_map</p><pre class="codeinput">params_group = values(mp_cl_mt_xyz_of_s, {<span class="string">'ar_st_y_name'</span>});
[ar_st_y_name] = params_group{:};
</pre><h2 id="6"><b>f(y), f(c), f(a)</b>: Generate Key Distributional Statistics for Each outcome</h2><pre class="codeinput"><span class="keyword">for</span> it_y_ctr=1:length(ar_st_y_name)
</pre><h2 id="8"><b>f(y), f(c), f(a)</b>: Find p(outcome(states)), proability mass function for each outcome</h2><p>Using from tools: <a href="https://fanwangecon.github.io/CodeDynaAsset/tools/html/ff_disc_rand_var_mass2outcomes.html">ff_disc_rand_var_mass2outcomes</a>, compute unique sorted outcomes for y(a,z) and find:</p><p><img src="ff_simu_stats_eq07860812722477683876.png" alt="$$ p(y,z) = \sum_{a} \left(1\left\{Y(a,z)=y\right\} \cdot p(a,z) \right)$$"></p><p><img src="ff_simu_stats_eq08810890118983211153.png" alt="$$ p(y,a) = \sum_{z} \left(1\left\{Y(a,z)=y\right\} \cdot p(a,z) \right)$$"></p><p><img src="ff_simu_stats_eq16910297080260075404.png" alt="$$ p(Y=y) = \sum_{a,z} \left( 1\left\{Y(a,z)=y\right\} \cdot p(a,z) \right)$$"></p><p>note: sum(mt_dist_az, 2) = result_map('cl_mt_pol_a'){2}, but not at small simulation grids. These two might be different because pol_a is based on a choices, mt_dist_az is based on a states</p><pre class="codeinput">    st_y_key = ar_st_y_name(it_y_ctr);
    cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_y_key);
    mt_y_of_s = cl_mt_xyz_of_s{1};

    <span class="comment">% run function ff_disc_rand_var_mass2outcomes.m</span>
    <span class="keyword">if</span> (size(mt_y_of_s, 2) == 1)
        <span class="comment">% matrix inputs are single column</span>
        [ar_f_of_y, ar_y_unique_sorted] = <span class="keyword">...</span>
            ff_disc_rand_var_mass2outcomes(st_y_key, mt_y_of_s, mt_f_of_s, bl_display_drvm2outcomes);
    <span class="keyword">else</span>
        <span class="comment">% matrix inputs are multi-column</span>
        [ar_f_of_y, ar_y_unique_sorted, mt_f_of_y_srow, mt_f_of_y_scol] = <span class="keyword">...</span>
            ff_disc_rand_var_mass2outcomes(st_y_key, mt_y_of_s, mt_f_of_s, bl_display_drvm2outcomes);
    <span class="keyword">end</span>
</pre><h2 id="9"><b>f(y), f(c), f(a)</b>: Compute Statistics for outcomes</h2><div><ul><li>$\mu_Y = E(Y) = \sum_{y} p(Y=y) \cdot y $</li><li><img src="ff_simu_stats_eq03728111283668325077.png" alt="$\sigma_Y = \sqrt{ \sum_{y} p(Y=y) \cdot \left( y - \mu_y \right)^2}$"></li><li><img src="ff_simu_stats_eq05433369603455155594.png" alt="$p(y=0)$"></li><li><img src="ff_simu_stats_eq09585247606302904929.png" alt="$p(y=\max(y))$"></li><li>percentiles: <img src="ff_simu_stats_eq09488738859326996168.png" alt="$min_{y} \left\{ P(Y \le y) - percentile \mid P(Y \le y) \ge percentile \right\}$"></li><li>fraction of outcome held by up to percentiles: <img src="ff_simu_stats_eq11722476300337688867.png" alt="$E(Y<y)/E(Y)$"></li></ul></div><pre class="codeinput">    <span class="comment">% run function ff_disc_rand_var_stats.m from tools:</span>
    [ds_stats_map] = ff_disc_rand_var_stats(st_y_key, ar_y_unique_sorted', ar_f_of_y', <span class="keyword">...</span>
        ar_fl_percentiles, bl_display_drvstats);

    <span class="comment">% prcess results</span>
    <span class="comment">% retrieve scalar statistics:</span>
    fl_choice_mean = ds_stats_map(<span class="string">'fl_choice_mean'</span>);
    fl_choice_sd = ds_stats_map(<span class="string">'fl_choice_sd'</span>);
    fl_choice_coefofvar = ds_stats_map(<span class="string">'fl_choice_coefofvar'</span>);
    fl_choice_min = ds_stats_map(<span class="string">'fl_choice_min'</span>);
    fl_choice_max = ds_stats_map(<span class="string">'fl_choice_max'</span>);
    fl_choice_prob_zero = ds_stats_map(<span class="string">'fl_choice_prob_zero'</span>);
    fl_choice_prob_below_zero = ds_stats_map(<span class="string">'fl_choice_prob_below_zero'</span>);
    fl_choice_prob_above_zero = ds_stats_map(<span class="string">'fl_choice_prob_above_zero'</span>);
    fl_choice_prob_min = ds_stats_map(<span class="string">'fl_choice_prob_min'</span>);
    fl_choice_prob_max = ds_stats_map(<span class="string">'fl_choice_prob_max'</span>);
    <span class="comment">% retrieve distributional array stats</span>
    ar_choice_percentiles = ds_stats_map(<span class="string">'ar_choice_percentiles'</span>);
    ar_choice_perc_fracheld = ds_stats_map(<span class="string">'ar_choice_perc_fracheld'</span>);
</pre><h2 id="10"><b>f(y), f(c), f(a)</b>: Store Statistics Specific to Each Outcome</h2><p>see intro section</p><pre class="codeinput">    <span class="comment">% Append prob mass functions to ds_stats_map</span>
    <span class="keyword">if</span> (size(mt_y_of_s, 2) &gt; 1)
        ds_stats_map(<span class="string">'mt_f_of_y_srow'</span>) = mt_f_of_y_srow;
        ds_stats_map(<span class="string">'mt_choice_prob_byYA'</span>) = mt_f_of_y_scol;
    <span class="keyword">end</span>
    ds_stats_map(<span class="string">'ar_y_unique_sorted'</span>) = ar_y_unique_sorted;
    <span class="comment">%     fl_neg_sum = sum(ar_f_of_y&lt;0);</span>
    <span class="comment">%     if (fl_neg_sum &gt;= -1e20)</span>
    <span class="comment">%         warning('fl_neg_sum is too large')</span>
    <span class="comment">%     end</span>
    ar_f_of_y(ar_f_of_y&lt;0) = 0;
    ar_f_of_y = ar_f_of_y/sum(ar_f_of_y);
    <span class="comment">%     sum(ar_f_of_y)</span>
    ds_stats_map(<span class="string">'ar_f_of_y'</span>) = ar_f_of_y;
    <span class="comment">% ds_stats_map is second element of cell for the key for the variable</span>
    <span class="comment">% in result_map</span>
    cl_mt_xyz_of_s{2} = ds_stats_map;
    mp_cl_mt_xyz_of_s(st_y_key) = cl_mt_xyz_of_s;

    <span class="comment">% key stats</span>
    ar_keystats = [fl_choice_mean fl_choice_sd fl_choice_coefofvar fl_choice_min fl_choice_max <span class="keyword">...</span>
        fl_choice_prob_zero fl_choice_prob_below_zero fl_choice_prob_above_zero <span class="keyword">...</span>
        fl_choice_prob_min fl_choice_prob_max ar_choice_percentiles];
    cl_xyz_names(it_y_ctr) = st_y_key;
    <span class="keyword">if</span> (it_y_ctr == 1)
        mt_outcomes_meansdperc = ar_keystats;
        mt_outcomes_fracheld = ar_choice_perc_fracheld;
    <span class="keyword">else</span>
        mt_outcomes_meansdperc = [mt_outcomes_meansdperc; ar_keystats];
        mt_outcomes_fracheld = [mt_outcomes_fracheld; ar_choice_perc_fracheld];
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="comment">% Store Stats</span>
tb_outcomes_meansdperc = array2table(mt_outcomes_meansdperc);
ar_fl_percentiles = ds_stats_map(<span class="string">'ar_fl_percentiles'</span>);
cl_col_names = [<span class="string">'mean'</span>, <span class="string">'sd'</span>, <span class="string">'coefofvar'</span>, <span class="string">'min'</span>, <span class="string">'max'</span>, <span class="keyword">...</span>
    <span class="string">'pYis0'</span>, <span class="string">'pYls0'</span>, <span class="string">'pYgr0'</span>, <span class="string">'pYisMINY'</span>, <span class="string">'pYisMAXY'</span>, <span class="keyword">...</span>
    strcat(<span class="string">'p'</span>, string(ar_fl_percentiles))];
tb_outcomes_meansdperc.Properties.VariableNames = matlab.lang.makeValidName(cl_col_names);
tb_outcomes_meansdperc.Properties.RowNames = matlab.lang.makeValidName(cl_xyz_names);

<span class="keyword">if</span> (bl_display_detail)
    disp(<span class="string">'xxx tb_outcomes_meansdperc: mean, sd, percentiles xxx'</span>)
    disp(rows2vars(tb_outcomes_meansdperc));
<span class="keyword">end</span>

<span class="comment">% Process Aset Held by up to percentiles</span>
tb_outcomes_fracheld = array2table(mt_outcomes_fracheld);
cl_col_names = [strcat(<span class="string">'fracByP'</span>, string(ar_fl_percentiles))];
tb_outcomes_fracheld.Properties.VariableNames = matlab.lang.makeValidName(cl_col_names);
tb_outcomes_fracheld.Properties.RowNames = matlab.lang.makeValidName(cl_xyz_names);

<span class="keyword">if</span> (bl_display_detail)
    disp(<span class="string">'xxx tb_outcomes_fracheld: fraction of asset/income/etc held by hh up to this percentile xxx'</span>)
    disp(rows2vars(tb_outcomes_fracheld));
<span class="keyword">end</span>
</pre><h2 id="12">Covariance and Correlation</h2><p>Having computed elsewhere E(X), E(Y), and SD(X), SD(Y), and given X(a,z) and Y(a,z), which are the optimal choices along the endogenous state space grid a, and the exogenous state space grid z, and given also f(a,z), the probability mass function over (a,z), we compute covariance and correlation between outcomes X and Y.</p><div><ul><li>Covariance</li></ul></div><p><img src="ff_simu_stats_eq05840240166657787077.png" alt="$$\mathrm{Cov}\left(x,y\right) = \sum_{a} \sum_{z} f(a,z) \cdot \left( x(a,z) - \mu_x \right) \cdot \left( y(a,z) - \mu_y \right)$$"></p><div><ul><li>Correlation</li></ul></div><p><img src="ff_simu_stats_eq16097707096021807928.png" alt="$$\rho_{x,y} = \frac{\mathrm{Cov}\left(x,y\right)}{\sigma_x \cdot \sigma_y}$$"></p><pre class="codeinput"><span class="keyword">for</span> it_x_ctr=1:length(ar_st_y_name)

    <span class="comment">% Get X Info</span>
    st_x_key = ar_st_y_name(it_x_ctr);
    cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_x_key);
    ds_stats_map = cl_mt_xyz_of_s{2};
    cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_x_key);
    mt_x_of_s = cl_mt_xyz_of_s{1};
    fl_x_mean = ds_stats_map(<span class="string">'fl_choice_mean'</span>);
    fl_x_sd = ds_stats_map(<span class="string">'fl_choice_sd'</span>);

    <span class="comment">% Initiate storage</span>
    ar_fl_cov_var_xy = zeros([1,length(ar_st_y_name)*2]);
    ar_st_covvar = strings([1,length(ar_st_y_name)*2]);

    <span class="keyword">for</span> it_y_ctr=1:length(ar_st_y_name)

        <span class="comment">% Get y Info</span>
        st_y_key = ar_st_y_name(it_y_ctr);
        cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_y_key);
        ds_stats_map = cl_mt_xyz_of_s{2};
        cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_y_key);
        mt_y_of_s = cl_mt_xyz_of_s{1};
        fl_y_mean = ds_stats_map(<span class="string">'fl_choice_mean'</span>);
        fl_y_sd = ds_stats_map(<span class="string">'fl_choice_sd'</span>);

        <span class="comment">% call ff_disc_rand_var_mass2covcor.m</span>
        [fl_cov_xy, fl_cor_xy] = ff_disc_rand_var_mass2covcor(<span class="keyword">...</span>
            mt_x_of_s, mt_y_of_s, mt_f_of_s, <span class="keyword">...</span>
            fl_x_mean, fl_x_sd, <span class="keyword">...</span>
            fl_y_mean, fl_y_sd, bl_display_drvm2covcor);

        <span class="comment">% only include the y name, x name is from the row</span>
        st_x_y_cov = strjoin([<span class="string">"fl_cov_"</span> st_y_key], <span class="string">''</span>);
        st_x_y_cor = strjoin([<span class="string">"fl_cor_"</span> st_y_key], <span class="string">''</span>);
        ds_stats_map(st_x_y_cov) = fl_cov_xy;
        ds_stats_map(st_x_y_cor) = fl_cor_xy;

        ar_fl_cov_var_xy(it_y_ctr*2-1) = fl_cov_xy;
        ar_fl_cov_var_xy(it_y_ctr*2) = fl_cor_xy;
        ar_st_covvar(it_y_ctr*2-1) = string(st_x_y_cov);
        ar_st_covvar(it_y_ctr*2) = string(st_x_y_cor);

        cl_mt_xyz_of_s{2} = ds_stats_map;
        mp_cl_mt_xyz_of_s(st_y_key) = cl_mt_xyz_of_s;
    <span class="keyword">end</span>

    <span class="keyword">if</span> (it_x_ctr == 1)
        mt_fl_cov_var_xy = ar_fl_cov_var_xy;
    <span class="keyword">else</span>
        mt_fl_cov_var_xy = [mt_fl_cov_var_xy; ar_fl_cov_var_xy];
    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="comment">% Store Stats</span>
tb_fl_cov_var_xy = array2table(mt_fl_cov_var_xy);
tb_fl_cov_var_xy.Properties.VariableNames = matlab.lang.makeValidName(ar_st_covvar);
tb_fl_cov_var_xy.Properties.RowNames = matlab.lang.makeValidName(cl_xyz_names);

<span class="keyword">if</span> (bl_display_detail)
    disp(<span class="string">'xxx tb_outcomes_covvar: variance correlation xxx'</span>)
    disp(rows2vars(tb_fl_cov_var_xy));
<span class="keyword">end</span>
</pre><h2 id="13"><b>f(y), f(c), f(a)</b>: Store Statistics Shared Table All Outcomes</h2><pre class="codeinput"><span class="comment">% Add to result_map</span>
mt_outcomes = [mt_outcomes_meansdperc, mt_fl_cov_var_xy, mt_outcomes_fracheld];
mp_cl_mt_xyz_of_s(<span class="string">'mt_outcomes'</span>) = mt_outcomes;
<span class="comment">% Store Stats</span>
tb_outcomes = [tb_outcomes_meansdperc, tb_fl_cov_var_xy, tb_outcomes_fracheld];
mp_cl_mt_xyz_of_s(<span class="string">'tb_outcomes'</span>) = tb_outcomes;

<span class="keyword">if</span> (bl_display_final)
    disp(<span class="string">'xxx tb_outcomes: all stats xxx'</span>)
    disp(rows2vars(tb_outcomes));
<span class="keyword">end</span>
</pre><pre class="codeoutput">xxx tb_outcomes: all stats xxx
    OriginalVariableNames     cl_mt_pol_a    cl_mt_pol_c
    ______________________    ___________    ___________

    {'mean'              }     -0.11081          8.8423 
    {'sd'                }       4.1239          6.5845 
    {'coefofvar'         }      -37.215         0.74466 
    {'min'               }           -7         -6.3772 
    {'max'               }            9          21.786 
    {'pYis0'             }     0.064259               0 
    {'pYls0'             }      0.54867        0.027329 
    {'pYgr0'             }      0.38707         0.97267 
    {'pYisMINY'          }     0.051764        0.015232 
    {'pYisMAXY'          }     0.027329        0.046484 
    {'p1'                }           -7         -6.3772 
    {'p10'               }           -6         0.27238 
    {'p25'               }           -3          5.2138 
    {'p50'               }           -1          6.5321 
    {'p75'               }            3          13.799 
    {'p90'               }            5          16.887 
    {'p99'               }            9          21.786 
    {'fl_cov_cl_mt_pol_a'}       17.007         -22.084 
    {'fl_cor_cl_mt_pol_a'}            1        -0.81327 
    {'fl_cov_cl_mt_pol_c'}      -22.084          43.356 
    {'fl_cor_cl_mt_pol_c'}     -0.81327               1 
    {'fracByP1'          }       3.2699       -0.010985 
    {'fracByP10'         }       5.9889       -0.013362 
    {'fracByP25'         }       14.165        0.041007 
    {'fracByP50'         }       16.208          0.1893 
    {'fracByP75'         }       12.702         0.59539 
    {'fracByP90'         }       6.6611          0.8307 
    {'fracByP99'         }            1               1 

</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

  Map with properties:

        Count: 5
      KeyType: char
    ValueType: any

</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% FF_SIMU_STATS Gateway Probability Mass Statistics
%    Given probability mass function f(s), and information y(s), x(s), z(s)
%    at each element of the state-space, compute statistics for each
%    variable, y, x, z, which are all discrete random variables. And
%    compute their correlation and covariance. The function can take any
%    number of outcome matrixes, y(s), ..., z(s), stored as values of
%    associated with keys that name these variables in a container map.
%
%    * MT_F_OF_S matrix or array probability mass at each s point
%    * MP_MT_XYZ_OF_S container map of matrix with MT_X_OF_S
%    * MP_SUPPORT_EXT container map with various control strings with
%    defaults
%
%    MP_MT_XYZ_OF_S keys and Example Values: 
%
%    mp_mt_xyz_of_s = containers.Map('KeyType', 'char', 'ValueType', 'any');
%    mp_mt_xyz_of_s('ar_st_y_name') = {'cl_mt_pol_a', 'cl_mt_pol_b', 'cl_mt_pol_c'};
%    mp_mt_xyz_of_s('cl_mt_pol_a') = {mt_pol_a, zeros(1)};
%    mp_mt_xyz_of_s('cl_mt_pol_b') = {mt_pol_b, zeros(1)};
%    mp_mt_xyz_of_s('cl_mt_pol_c') = {mt_pol_b, zeros(1)};
%
%    MP_MT_XYZ_OF_S = FF_SIMU_STATS() default simulation stats outputs.
%
%    MP_MT_XYZ_OF_S = FF_DISC_RAND_VAR_MASS2COVCOR(MT_F_OF_S,
%    MP_CL_MT_XYZ_OF_S) calculates various statistics given the provided
%    distribution matrix and various outcome/states matrixes.
%
%    MP_MT_XYZ_OF_S = FF_DISC_RAND_VAR_MASS2COVCOR(MT_F_OF_S,
%    MP_CL_MT_XYZ_OF_S, MP_SUPPORT_EXT) provides some additional control
%    strings if to print verbose in each stat function.
%
%    See also FX_SIMU_STATS
%

%%
function mp_cl_mt_xyz_of_s = ff_simu_stats(varargin)
%% FF_SIMU_STATS post simulation statistics generation
% Having derived f(a,z) the probability mass function of the joint discrete
% random variables, we now obtain distributional statistics. Note that we
% know f(a,z), and we also know relevant policy functions a'(a,z), c(a,z),
% or other policy functions. We can simulate any choices that are a
% function of the random variables (a,z), using f(a,z)
%
% parameter structure provides a list of
%
% # from result_map('ar_st_y_name'), get list of outcome matrix on state
% space
% # simulate each outcome using f(a,z) for probability draws
% # compute key statistics: (1) mean (expectation=sum) (2) sd (3) min and
% max (4) iqr (5) fraction = 0 (6) percentiles including: 99.9, 99, 95,
% every 5 in between 5, 1, 0.01.
%
% Uses fake binomial data when file is invoke with defaults.
%
% * the first element of each of these cell array is y(a,z), the
% outcome/choice at the state space points
% * the second element of the cell is another container, which contains
% statistics computed for f(y) based on y(a,z) and f(a,z), f(y) is the
% probability mass function for outcome y given the stationary distribution
% f(a,z). The second element container also includes f(y) itself as well as
% f(y,z).
% * additionally, result_map also stores some of the statistics for
% different variables jointly together. (a) *tb_outcomes_meansdperc*: where
% each row is a different outcome of the model, and each table column
% stores a different statistics of interest. (b) *tb_outcomes_fracheld*:
% which measures the fraction of asset held by different people.
%


%% Default
% use binomial as test case, z maps to binomial win prob, remember binom
% approximates normal.

if (~isempty(varargin))
    
    if (length(varargin)==2)
        [mt_f_of_s, mp_cl_mt_xyz_of_s] = varargin{:};
    elseif (length(varargin)==3)
        [mt_f_of_s, mp_cl_mt_xyz_of_s, mp_support_ext] = varargin{:};
    end
    
    % if invoked from outside overrid fully
else
    
    it_states = 6;
    it_shocks = 5;
    fl_binom_n = it_states-1;
    ar_binom_p = (1:(it_shocks))./(it_shocks+2);
    ar_binom_x = (0:1:(it_states-1)) -3;
    
    % f(z)
    ar_binom_p_prob = binopdf(0:(it_shocks-1), it_shocks-1, 0.5);
    % f(a,z), mass for a, z
    mt_f_of_s = zeros([it_states, it_shocks]);
    for it_z=1:it_shocks
        % f(a|z)
        f_a_condi_z = binopdf(ar_binom_x - min(ar_binom_x), fl_binom_n, ar_binom_p(it_z));
        % f(z)
        f_z = ar_binom_p_prob(it_z);
        % f(a,z)=f(a|z)*f(z)
        mt_f_of_s(:, it_z) = f_a_condi_z*f_z;
    end
    
    % y(a,z), some non-smooth structure
    rng(123);
    mt_pol_a = ar_binom_x' - 0.01*ar_binom_x'.^2  + ar_binom_p - 0.5*ar_binom_p.^2 + rand([it_states, it_shocks]);
    mt_pol_a = round(mt_pol_a*3);
    
    rng(456);
    mt_pol_c = 10 -(mt_pol_a) + 15*(rand([it_states, it_shocks])-0.5);
    
    % Generate result_map
    % two column, the second zero(1) component left for disc rand var of a,
    % c
    mp_cl_mt_xyz_of_s = containers.Map('KeyType','char', 'ValueType','any');
    mp_cl_mt_xyz_of_s('cl_mt_pol_a') = {mt_pol_a, zeros(1)};
    mp_cl_mt_xyz_of_s('cl_mt_pol_c') = {mt_pol_c, zeros(1)};
    mp_cl_mt_xyz_of_s('ar_st_y_name') = ["cl_mt_pol_a", "cl_mt_pol_c"];
    
end

%% Set and Update Support Map
mp_support = containers.Map('KeyType','char', 'ValueType','any');
mp_support('bl_display_detail') = false;
mp_support('bl_display_final') = true;

% for ff_disc_rand_var_mass2outcomes.m
mp_support('bl_display_drvm2outcomes') = false;

% for ff_disc_rand_var_stats.m
mp_support('ar_fl_percentiles') = [1 10 25 50 75 90 99];
mp_support('bl_display_drvstats') = false;

% for ff_disc_rand_var_stats.m
mp_support('bl_display_drvm2covcor') = false;

% override default support_map values
if (length(varargin)==3)
    mp_support = [mp_support; mp_support_ext];
end

% Parse Support_map
params_group = values(mp_support, {'bl_display_detail', 'bl_display_final'});
[bl_display_detail, bl_display_final] = params_group{:};
params_group = values(mp_support, {'bl_display_drvm2outcomes'});
[bl_display_drvm2outcomes] = params_group{:};
params_group = values(mp_support, {'ar_fl_percentiles', 'bl_display_drvstats'});
[ar_fl_percentiles, bl_display_drvstats] = params_group{:};
params_group = values(mp_support, {'bl_display_drvm2covcor'});
[bl_display_drvm2covcor] = params_group{:};

%% Parse mp_mt_xyz_of_s
% result_map
params_group = values(mp_cl_mt_xyz_of_s, {'ar_st_y_name'});
[ar_st_y_name] = params_group{:};

%% *f(y), f(c), f(a)*: Generate Key Distributional Statistics for Each outcome

for it_y_ctr=1:length(ar_st_y_name)
    
    %% *f(y), f(c), f(a)*: Find p(outcome(states)), proability mass function for each outcome
    % Using from tools:
    % <https://fanwangecon.github.io/CodeDynaAsset/tools/html/ff_disc_rand_var_mass2outcomes.html
    % ff_disc_rand_var_mass2outcomes>, compute unique sorted outcomes for
    % y(a,z) and find:
    %
    % $$ p(y,z) = \sum_{a} \left(1\left\{Y(a,z)=y\right\} \cdot p(a,z) \right)$$
    %
    % $$ p(y,a) = \sum_{z} \left(1\left\{Y(a,z)=y\right\} \cdot p(a,z) \right)$$
    %
    % $$ p(Y=y) = \sum_{a,z} \left( 1\left\{Y(a,z)=y\right\} \cdot p(a,z) \right)$$
    %
    % note: sum(mt_dist_az, 2) = result_map('cl_mt_pol_a'){2}, but not at
    % small simulation grids. These two might be different because pol_a is
    % based on a choices, mt_dist_az is based on a states
    %
    
    st_y_key = ar_st_y_name(it_y_ctr);
    cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_y_key);
    mt_y_of_s = cl_mt_xyz_of_s{1};
    
    % run function ff_disc_rand_var_mass2outcomes.m
    if (size(mt_y_of_s, 2) == 1)
        % matrix inputs are single column
        [ar_f_of_y, ar_y_unique_sorted] = ...
            ff_disc_rand_var_mass2outcomes(st_y_key, mt_y_of_s, mt_f_of_s, bl_display_drvm2outcomes);
    else
        % matrix inputs are multi-column
        [ar_f_of_y, ar_y_unique_sorted, mt_f_of_y_srow, mt_f_of_y_scol] = ...
            ff_disc_rand_var_mass2outcomes(st_y_key, mt_y_of_s, mt_f_of_s, bl_display_drvm2outcomes);
    end
    
    %% *f(y), f(c), f(a)*: Compute Statistics for outcomes
    %
    % * $\mu_Y = E(Y) = \sum_{y} p(Y=y) \cdot y $
    % * $\sigma_Y = \sqrt{ \sum_{y} p(Y=y) \cdot \left( y - \mu_y \right)^2}$
    % * $p(y=0)$
    % * $p(y=\max(y))$
    % * percentiles: $min_{y} \left\{ P(Y \le y) - percentile \mid P(Y \le y) \ge percentile \right\}$
    % * fraction of outcome held by up to percentiles: $E(Y<y)/E(Y)$
    %
    
    % run function ff_disc_rand_var_stats.m from tools:
    [ds_stats_map] = ff_disc_rand_var_stats(st_y_key, ar_y_unique_sorted', ar_f_of_y', ...
        ar_fl_percentiles, bl_display_drvstats);
    
    % prcess results
    % retrieve scalar statistics:
    fl_choice_mean = ds_stats_map('fl_choice_mean');
    fl_choice_sd = ds_stats_map('fl_choice_sd');
    fl_choice_coefofvar = ds_stats_map('fl_choice_coefofvar');
    fl_choice_min = ds_stats_map('fl_choice_min');
    fl_choice_max = ds_stats_map('fl_choice_max');
    fl_choice_prob_zero = ds_stats_map('fl_choice_prob_zero');
    fl_choice_prob_below_zero = ds_stats_map('fl_choice_prob_below_zero');
    fl_choice_prob_above_zero = ds_stats_map('fl_choice_prob_above_zero');
    fl_choice_prob_min = ds_stats_map('fl_choice_prob_min');
    fl_choice_prob_max = ds_stats_map('fl_choice_prob_max');
    % retrieve distributional array stats
    ar_choice_percentiles = ds_stats_map('ar_choice_percentiles');
    ar_choice_perc_fracheld = ds_stats_map('ar_choice_perc_fracheld');
    
    %% *f(y), f(c), f(a)*: Store Statistics Specific to Each Outcome
    % see intro section
    
    % Append prob mass functions to ds_stats_map
    if (size(mt_y_of_s, 2) > 1)
        ds_stats_map('mt_f_of_y_srow') = mt_f_of_y_srow;
        ds_stats_map('mt_choice_prob_byYA') = mt_f_of_y_scol;
    end
    ds_stats_map('ar_y_unique_sorted') = ar_y_unique_sorted;
    %     fl_neg_sum = sum(ar_f_of_y<0);
    %     if (fl_neg_sum >= -1e20)
    %         warning('fl_neg_sum is too large')
    %     end
    ar_f_of_y(ar_f_of_y<0) = 0;
    ar_f_of_y = ar_f_of_y/sum(ar_f_of_y);
    %     sum(ar_f_of_y)
    ds_stats_map('ar_f_of_y') = ar_f_of_y;
    % ds_stats_map is second element of cell for the key for the variable
    % in result_map
    cl_mt_xyz_of_s{2} = ds_stats_map;
    mp_cl_mt_xyz_of_s(st_y_key) = cl_mt_xyz_of_s;
    
    % key stats
    ar_keystats = [fl_choice_mean fl_choice_sd fl_choice_coefofvar fl_choice_min fl_choice_max ...
        fl_choice_prob_zero fl_choice_prob_below_zero fl_choice_prob_above_zero ...
        fl_choice_prob_min fl_choice_prob_max ar_choice_percentiles];
    cl_xyz_names(it_y_ctr) = st_y_key;
    if (it_y_ctr == 1)
        mt_outcomes_meansdperc = ar_keystats;
        mt_outcomes_fracheld = ar_choice_perc_fracheld;
    else
        mt_outcomes_meansdperc = [mt_outcomes_meansdperc; ar_keystats];
        mt_outcomes_fracheld = [mt_outcomes_fracheld; ar_choice_perc_fracheld];
    end
    
end

% Store Stats    
tb_outcomes_meansdperc = array2table(mt_outcomes_meansdperc);
ar_fl_percentiles = ds_stats_map('ar_fl_percentiles');
cl_col_names = ['mean', 'sd', 'coefofvar', 'min', 'max', ...
    'pYis0', 'pYls0', 'pYgr0', 'pYisMINY', 'pYisMAXY', ...
    strcat('p', string(ar_fl_percentiles))];
tb_outcomes_meansdperc.Properties.VariableNames = matlab.lang.makeValidName(cl_col_names);
tb_outcomes_meansdperc.Properties.RowNames = matlab.lang.makeValidName(cl_xyz_names);

if (bl_display_detail)
    disp('xxx tb_outcomes_meansdperc: mean, sd, percentiles xxx')
    disp(rows2vars(tb_outcomes_meansdperc));
end

% Process Aset Held by up to percentiles
tb_outcomes_fracheld = array2table(mt_outcomes_fracheld);
cl_col_names = [strcat('fracByP', string(ar_fl_percentiles))];
tb_outcomes_fracheld.Properties.VariableNames = matlab.lang.makeValidName(cl_col_names);
tb_outcomes_fracheld.Properties.RowNames = matlab.lang.makeValidName(cl_xyz_names);

if (bl_display_detail)
    disp('xxx tb_outcomes_fracheld: fraction of asset/income/etc held by hh up to this percentile xxx')
    disp(rows2vars(tb_outcomes_fracheld));
end    

%% Covariance and Correlation
% Having computed elsewhere E(X), E(Y), and SD(X), SD(Y), and given X(a,z)
% and Y(a,z), which are the optimal choices along the endogenous state
% space grid a, and the exogenous state space grid z, and given also
% f(a,z), the probability mass function over (a,z), we compute covariance
% and correlation between outcomes X and Y.
%
% * Covariance
%
% $$\mathrm{Cov}\left(x,y\right) = \sum_{a} \sum_{z} f(a,z) \cdot \left( x(a,z) - \mu_x \right) \cdot \left( y(a,z) - \mu_y \right)$$
%
% * Correlation
%
% $$\rho_{x,y} = \frac{\mathrm{Cov}\left(x,y\right)}{\sigma_x \cdot \sigma_y}$$

for it_x_ctr=1:length(ar_st_y_name)
    
    % Get X Info
    st_x_key = ar_st_y_name(it_x_ctr);
    cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_x_key);
    ds_stats_map = cl_mt_xyz_of_s{2};
    cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_x_key);
    mt_x_of_s = cl_mt_xyz_of_s{1};
    fl_x_mean = ds_stats_map('fl_choice_mean');
    fl_x_sd = ds_stats_map('fl_choice_sd');
    
    % Initiate storage
    ar_fl_cov_var_xy = zeros([1,length(ar_st_y_name)*2]);
    ar_st_covvar = strings([1,length(ar_st_y_name)*2]);
    
    for it_y_ctr=1:length(ar_st_y_name)
        
        % Get y Info
        st_y_key = ar_st_y_name(it_y_ctr);
        cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_y_key);
        ds_stats_map = cl_mt_xyz_of_s{2};
        cl_mt_xyz_of_s = mp_cl_mt_xyz_of_s(st_y_key);
        mt_y_of_s = cl_mt_xyz_of_s{1};
        fl_y_mean = ds_stats_map('fl_choice_mean');
        fl_y_sd = ds_stats_map('fl_choice_sd');
        
        % call ff_disc_rand_var_mass2covcor.m
        [fl_cov_xy, fl_cor_xy] = ff_disc_rand_var_mass2covcor(...
            mt_x_of_s, mt_y_of_s, mt_f_of_s, ...
            fl_x_mean, fl_x_sd, ...
            fl_y_mean, fl_y_sd, bl_display_drvm2covcor);
        
        % only include the y name, x name is from the row
        st_x_y_cov = strjoin(["fl_cov_" st_y_key], '');
        st_x_y_cor = strjoin(["fl_cor_" st_y_key], '');
        ds_stats_map(st_x_y_cov) = fl_cov_xy;
        ds_stats_map(st_x_y_cor) = fl_cor_xy;
        
        ar_fl_cov_var_xy(it_y_ctr*2-1) = fl_cov_xy;
        ar_fl_cov_var_xy(it_y_ctr*2) = fl_cor_xy;
        ar_st_covvar(it_y_ctr*2-1) = string(st_x_y_cov);
        ar_st_covvar(it_y_ctr*2) = string(st_x_y_cor);
        
        cl_mt_xyz_of_s{2} = ds_stats_map;
        mp_cl_mt_xyz_of_s(st_y_key) = cl_mt_xyz_of_s;
    end
    
    if (it_x_ctr == 1)
        mt_fl_cov_var_xy = ar_fl_cov_var_xy;
    else
        mt_fl_cov_var_xy = [mt_fl_cov_var_xy; ar_fl_cov_var_xy];
    end
    
end

% Store Stats       
tb_fl_cov_var_xy = array2table(mt_fl_cov_var_xy);
tb_fl_cov_var_xy.Properties.VariableNames = matlab.lang.makeValidName(ar_st_covvar);
tb_fl_cov_var_xy.Properties.RowNames = matlab.lang.makeValidName(cl_xyz_names);

if (bl_display_detail)
    disp('xxx tb_outcomes_covvar: variance correlation xxx')
    disp(rows2vars(tb_fl_cov_var_xy));
end


%% *f(y), f(c), f(a)*: Store Statistics Shared Table All Outcomes

% Add to result_map
mt_outcomes = [mt_outcomes_meansdperc, mt_fl_cov_var_xy, mt_outcomes_fracheld];
mp_cl_mt_xyz_of_s('mt_outcomes') = mt_outcomes;
% Store Stats    
tb_outcomes = [tb_outcomes_meansdperc, tb_fl_cov_var_xy, tb_outcomes_fracheld];
mp_cl_mt_xyz_of_s('tb_outcomes') = tb_outcomes;

if (bl_display_final)
    disp('xxx tb_outcomes: all stats xxx')        
    disp(rows2vars(tb_outcomes));    
end

end

##### SOURCE END #####
--></body></html>